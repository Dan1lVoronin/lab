[.text-center]
[.big]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ

[.text-center]
Федеральное государственное автономное образовательное учреждение  
высшего образования «Южно-Уральский государственный университет»  
(национальный исследовательский университет)

[.text-center]
Высшая школа электроники и компьютерных наук  
Кафедра информационно-измерительная техника

'''

[.text-center]
[.bold]
== ЛАБОРАТОРНАЯ РАБОТА №1  
=== по дисциплине  
=== «Программное обеспечение измерительных процессов»

'''

[.text-right]
*_Выполнил:_* +  
студент группы КЭ-206 +  
Д.М. Воронин

'''

[.text-center]
Челябинск 2025


== Почему код пишут самые низкоквалифицированные инженеры

Разработка программного обеспечения состоит из нескольких этапов. На первом этапе старшие инженеры и архитекторы разрабатывают концепцию продукта, определяют его структуру и выбирают технологии. Затем работа передается разработчикам, которые пишут код на основе уже подготовленных решений.

== Основные этапы разработки

=== 1. Проектирование
Ведущие специалисты анализируют требования, продумывают архитектуру, выбирают технологии и определяют, как разные части системы будут взаимодействовать между собой. Это сложная работа, требующая опыта и глубокого понимания предметной области.

=== 2. Написание кода
После проектирования задачи дробятся на небольшие части и передаются разработчикам. Большую часть кода пишут младшие и средние инженеры, так как процесс программирования в этом контексте представляет собой реализацию уже продуманных решений.

=== 3. Тестирование
Готовый код проверяется с помощью автоматизированных тестов, ручного тестирования и код-ревью. Это позволяет обнаружить ошибки и отклонения от требований. 

=== 4. Развертывание и поддержка
После тестирования программное обеспечение внедряется в эксплуатацию. Далее оно поддерживается и дорабатывается по мере необходимости.

== Как работает компиляция в IAR Workbench for ARM?

При разработке программного обеспечения для микроконтроллеров код на *C++* нужно преобразовать в исполняемый файл. Этот процесс включает два основных этапа.

=== 1. Трансляция кода в объектный файл

На этом этапе *компилятор* берет исходный код и превращает его в *объектные файлы*.

В результате мы получаем:

- *Объектные файлы* с машинным кодом, готовые для дальнейшей обработки;
- *Библиотеки*, которые можно подключать в других проектах.

=== 2. Компоновка в исполняемый файл

Здесь в дело вступает *линковщик*. Он объединяет объектные файлы, библиотеки и формирует *исполнимый образ* программы.

На этом этапе используются:

- *Объектные файлы*, полученные на предыдущем шаге;
- *Внешние библиотеки*, подключенные в проекте;
- *Стандартные библиотеки C++*;
- *Конфигурационный файл*, который определяет, где в памяти микроконтроллера разместится код и данные.

В результате работы линковщика создается *исполняемый файл*, который можно загрузить в микроконтроллер.

=== 3. Запуск и отладка

После компоновки IAR генерирует *файл в формате ELF*, который можно использовать для:

- *Загрузки в отладчик* (например, IAR-CSPY или GDB);
- *Записи во флеш-память микроконтроллера* через программатор.

== Запуск функции main() в микроконтроллере

Прежде чем программа начнет выполняться, микроконтроллер выполняет несколько подготовительных действий.

=== 1. Инициализация стека и переменных

Выделяется память под *стек* (где хранятся локальные переменные и вызовы функций), а также инициализируются глобальные и статические переменные.

=== 2. Копирование данных из ПЗУ в ОЗУ

Часть данных, сохраненных в *постоянной памяти* (ПЗУ) при компиляции, переносится в *оперативную память* (ОЗУ) для быстрого доступа во время работы программы.

=== 3. Настройка периферии

Микроконтроллер настраивает встроенные устройства — таймеры, GPIO, интерфейсы и другие модули. Это обычно выполняется с помощью стандартных библиотек и драйверов.

=== 4. Запуск main()

Когда все подготовительные шаги завершены, управление передается в `main()`, и начинается выполнение основной программы.

[NOTE]
====
До запуска `main()` выполняются:
1. Инициализация стека и глобальных переменных;
2. Копирование данных из ПЗУ в ОЗУ;
3. Инициализация периферии;
4. Передача управления в `main()`.
====

== Как работает static переменная в функции?

Пример кода:

[source,cpp]
----
#include <iostream>

int Increment(int value)
{
    static int result = value;
    result++;
    return result;
}

int main()
{
    auto result = Increment(10);
    std::cout << "result == " << result << std::endl; // 11

    result = Increment(12);
    std::cout << "result == " << result << std::endl; // 12
}
----

== Что здесь происходит?

Переменная `result` объявлена как `static`, а это значит, что:
- Она инициализируется **только один раз** — при первом вызове `Increment()`.
- После выхода из функции `result` **сохраняет своё значение**, а не создается заново при каждом вызове.

== Разберем пример

- При первом вызове `Increment(10)`, переменная `result` инициализируется значением `10`, затем увеличивается до `11`.
- При следующем вызове `Increment(12)`, переменная `result` **не инициализируется заново**. Она уже хранит `11` и просто увеличивается до `12`.

== Итог

Результат работы программы:
- Первый вывод: `result == 11`
- Второй вывод: `result == 12`