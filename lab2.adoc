== 1) Что узнал и что делал

=== Типы данных

* Целочисленные: `int`, `short`, `long`, `long long`
* Вещественные: `float`, `double`
* Символьные: `char`
* Размеры зависят от платформы, но стандартно:
** `int` — 4 байта
** `short` — 2 байта
** `char` — 1 байт

Размер можно узнать с помощью `sizeof(тип)`.

=== Преобразование типов

* *Неявное преобразование* — автоматическое преобразование компилятором (например, `int` в `float`)
* *Явное преобразование* — задаётся программистом:

** `static_cast<тип>(значение)` — безопасное преобразование между совместимыми типами
** `reinterpret_cast<тип>(значение)` — жёсткое преобразование, применяется только при необходимости

==== Почему преобразование типов может быть плохим:

* Потеря данных (например, `double` → `int` обрезает дробную часть)
* `reinterpret_cast` может привести к непредсказуемому поведению (undefined behavior)

=== Указатели

* Указатель хранит адрес переменной
* Операции с указателями:
** Разыменование: `*ptr`
** Арифметика: `ptr + 1`, `ptr - 1`
** Получение адреса: `&x`

*Нельзя вычитать указатели на разные объекты* — это может привести к неопределённому поведению

=== Побитовые операции

* Установить бит: `x |= (1 << n);`
* Сбросить бит: `x &= ~(1 << n);`
* Переключить (инвертировать) бит: `x ^= (1 << n);`

== 2) Унарный плюс и унарный минус

* `+x` — возвращает `x` как есть
* `-x` — меняет знак `x`

[source,cpp]
----
int a = 5;
int b = +a;  // b = 5
int c = -a;  // c = -5
----

== 3) Почему `float + 1 == float` при больших значениях

Если написать:

[source,cpp]
----
float x = 17000000;
float y = x + 1;
----

то `y` всё равно будет равно `17000000`. Это связано с *ограниченной точностью* `float`. При таких больших значениях единица становится слишком маленькой и "теряется", не влияя на результат.

== 4) Почему `7 != 7` в примере

Если в коде `7 != 7` возвращает `true`, то:

* Скорее всего, одно из чисел — результат вычислений с плавающей запятой (`float`, `double`)
* Из-за *ошибки округления* результат может быть чуть больше или меньше 7, например `7.0000001`, и тогда сравнение с `7` даст `false`

=== Правильный способ сравнивать вещественные числа:

[source,cpp]
----
#include <cmath>
if (fabs(a - b) < 0.0001) {
    // считаем числа равными
}
----
