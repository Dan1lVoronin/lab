== 1. Как работают прерывания

Прерывания — это способ временно приостановить выполнение основного кода, чтобы быстро отреагировать на какое-либо событие (например, переполнение таймера, приход данных по UART, внешнее изменение состояния пина и т.д.).

Когда происходит прерывание:
1. Процессор завершает выполнение текущей инструкции.
2. Выполняется переход по адресу из таблицы векторов прерываний.
3. Запускается функция-обработчик соответствующего прерывания.
4. После завершения обработчика выполнение основного кода продолжается.

=== Виды прерываний

* Внешние прерывания (например, с пина ввода)
* Внутренние (от таймеров, АЦП, UART и т.д.)
* Системные (например, SysTick, NMI, HardFault)

Прерывания могут иметь приоритет, и одни могут блокировать другие.

== 2. Контроллер прерываний NVIC

`NVIC` (Nested Vectored Interrupt Controller) — это модуль, встроенный в Cortex-M микроконтроллеры, который управляет прерываниями:
* Разрешает или запрещает конкретные прерывания
* Управляет приоритетами
* Позволяет вложенные прерывания (одно прерывание может быть прервано другим, более приоритетным)

NVIC — важная часть для правильной иерархии работы с прерываниями.

== 3. Таблица векторов прерываний

Таблица векторов — это область памяти, в которой хранятся адреса всех обработчиков прерываний. Она располагается по фиксированному адресу (обычно начинается с адреса 0x00000000 в STM32).

* Первый элемент таблицы — это указатель на начальный стек
* Все остальные — указатели на функции-обработчики

При возникновении прерывания контроллер использует таблицу, чтобы узнать, куда перейти.

== 4. Обработчик прерываний

Обработчик прерываний — это функция, которая вызывается при наступлении события. Она должна быть быстрой и выполнять только необходимые действия. Обычно в ней:

* Сбрасывается флаг прерывания
* Устанавливаются или изменяются переменные состояния
* По возможности — ничего долгого не делается (например, без задержек)

Пример шаблона обработчика на STM32 (с использованием HAL):

[source,c]
----
void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);
}
----

А дальше уже в `HAL_TIM_PeriodElapsedCallback()` можно обрабатывать событие логически.

== 5. Обработка переполнения таймера 2 через прерывание

Когда таймер 2 переполняется (то есть его счётчик доходит до максимального значения), он может сгенерировать прерывание.

Вот как это происходит по шагам:

1. Таймер 2 настраивается и запускается:
+
[source,c]
----
HAL_TIM_Base_Start_IT(&htim2);
----

2. При переполнении срабатывает прерывание. Процессор переходит в `TIM2_IRQHandler()`, т.к. его адрес прописан в таблице векторов.

3. Функция `TIM2_IRQHandler()` вызывает `HAL_TIM_IRQHandler()`, которая уже вызывает `HAL_TIM_PeriodElapsedCallback()` — в неё мы можем вставить нужные действия:
+
[source,c]
----
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        led_state = !led_state;
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, led_state);
    }
}
----

4. После выхода из обработчика выполнение основного кода продолжается.

== Заключение

Прерывания позволяют эффективно реагировать на внешние и внутренние события без постоянной проверки флагов в основном цикле. Главное — грамотно настроить NVIC, указать приоритеты и писать минималистичные, быстрые обработчики. Пример с таймером 2 показывает, как это работает на практике.
